v1


[Verse 1]
EA 0 3 0 2 E 3 2 1 0 3 2 1 0

EA 0 3 0 2 E 3 2 1 0 3 2 1 0

EA 0 3 0 2 E 3 2 1 0 3 2 1 0

EA 0 3 0 2 E 3 3 6 6 6 6 3 3

ADG 8 10 10 7 9 9 E 0 0 0 0 0 0 - - 0 0 0 0 0 0 - - 0 0 0 0 0 0 0 0

ADG 8 10 10 7 9 9 E 0 0 0 0 0 0 - - 0 0 0 0 0 0 - - 0 0 0 0 0 0 0 0

ADG 8 10 10 7 9 9 E 0 0 0 - 0 0 0 - 0 0 0 - 0 0 0 - 0 0 0 - 0 0 0


[Chorus]
EA 0 2 D 9 9 7 9 10 9 10 12 10 9 10 9 6

EA 0 2 D 9 9 7 9 10 9 10 12 10 9 10 9 6

D 12 7 12 7 12 7 12 7 12 7 12 7 12 7

D 10 7 10 7 10 7 10 7 10 7 10 7 10 7




def parse(tokens, resDict):


    print tokens
    state = []

    while tokens != []:
        reqTokens = []
        token, tokens = next_token(tokens)

        if token[0] == 'note':
            # check if state update
            if token[1][0].isalpha():
                state = []
                for char in token:
                    if char.isalpha():
                        state.append(char)
            else:
                reqTokens = [token]


            tokens, resDict = parse_state(state, tokens, reqTokens, resDict)


    return resDict
